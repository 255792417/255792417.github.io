{"posts":[{"title":"有关勒让德定理的思考","text":"前几天刷力扣遇到了一个考察阶乘性质的题 题目本身不难 可是要求O(logn)很快想到可以将尾随0分解成2*5，如此一来题目就很清晰了只需要找到有多少个2的倍数和5的倍数就行 根据次幂计数很容易想到统计2^n^和5^n^各出现了多少次，对应加n，然后取两个和较小的那个题中n&lt;=10000，代码可以这么写 12345678910111213141516a=[5,25,125,625,3125]b=[2,4,8,16,32,64,128,256,512,1024,2048,4096,8192]suma=sumb=0for i in range(n+1): for j in range(4): if i&gt;=a[j] and i&lt;a[j+1]: suma+=j+1 if i&gt;=a[4]: suma+=5for i in range(n+1): for j in range(12): if i&gt;=b[j] and i&lt;b[j+1]: sumb+=j+1 if i&gt;=b[12]: sumb+=13return min(suma,sumb) 这么写很直观，但是判断上太麻烦，能不能只要有i&gt;a[j]就计数呢？ 勒让德定理这就该引出勒让德定理了： 直观来说就是将竖着的楼梯横着计数于是乎代码就可以写成这样: 1234567a=[5,25,125,625,3125]b=[2,4,8,16,32,64,128,256,512,1024,2048,4096,8192]for i in range(5): a[i]=n//a[i]for i in range(13): b[i]=n//b[i]return min(sum(a),sum(b)) 进一步优化看起来就简介多了，实际上这种形式已经能击败100%了但是在思考阶乘中2和5出现的次数时不难发现，2的次数总少于5于是干脆舍弃对2计数，可以再精简一些: 1234a=[5,25,125,625,3125]for i in range(5): a[i]=n//a[i]return sum(a) 如此这道题从算法层面就圆满了 tips 这道题最佳写法如下: 12345ans = 0while n: n //= 5 ans += nreturn ans 对空间做了进一步优化","link":"/%E6%9C%89%E5%85%B3%E5%8B%92%E8%AE%A9%E5%BE%B7%E5%AE%9A%E7%90%86%E7%9A%84%E6%80%9D%E8%80%83.html"},{"title":"二分法开闭区间写法异同","text":"主要分为四类：(以二分查找为例) 闭区间 左开右闭 左闭右开 开区间 12345678left , right = 0 , n-1while left &lt;= right: mid = (left + right)//2 if nums[mid]&lt;target: left = mid + 1 else: right = mid - 1return left 12345678left , right = -1 , n-1while left &lt; right: mid = (left + right)//2 if nums[mid]&lt;target: left = mid else: right = mid - 1return right 12345678left , right = 0 , nwhile left &lt; right: mid = (left + right)//2 if nums[mid]&lt;target: left = mid + 1 else: right = midreturn left 12345678left , right = -1 , nwhile left+1 &lt; right: mid = (left + right)//2 if nums[mid]&lt;target: left = mid else: right = midreturn right tips 可以看到主要区别就是left，right的初始值，和mid是否+-1，可以很简单地理解为，开区间就是把一个边界向外扩大了1，也即相对mid更远了，因此所有计数都相应地外扩1","link":"/%E4%BA%8C%E5%88%86%E6%B3%95%E5%BC%80%E9%97%AD%E5%8C%BA%E9%97%B4%E5%86%99%E6%B3%95%E5%BC%82%E5%90%8C.html"},{"title":"做了一点dp后的总结","text":"算法日志-1这几天间间断断地在Leetcode上面写了一二十道DP，主要是： 爬楼梯打家劫舍网格图 虽然说没做太多，但是也算是有了一点感觉（其实还是菜，做不出来） 爬楼梯对于爬楼梯问题其实没什么好讲的，本质上和DFS很像，只不过一个是递，一个是归，这种情况下基本就是DP/DFS+记忆化搜索。 打家劫舍打家劫舍分为两类，一种是下标相邻有关，一种是值域相邻有关，下标类的相对好写，只需要找出单方向的递推简化过程，转化为状态转移方程，一步步求解就好。而值域相邻有关可以使用collections.Counter生成包含 元素-&gt;次数 的字典，将最大值+1作为len(dp)，同时初始化dp[i]为 元素大小*次数，转化为下标相邻有关问题.示例：740. 删除并获得点数给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。Example:输入：nums = [3,4,2]输出：6解释：删除 4 获得 4 个点数，因此 3 也被删除。之后，删除 2 获得 2 个点数。总共获得 6 个点数。 1 &lt;= nums.length &lt;= 2 * 104 1 &lt;= nums[i] &lt;= 104 题解: 12345678910class Solution: def deleteAndEarn(self, nums: List[int]) -&gt; int: cnt=Counter(nums) max_val=max(cnt.keys()) dp=[0] * (max_val+1) for i , j in cnt.items(): dp[i] = i * j for i in range(1 , max_val+1): dp[i]=max(dp[i-1] , (dp[i-2] if i&gt;=2 else 0) + dp[i]) return dp[-1] 网格图然后是网格图DP，网格图DP其实是抽象二维DP的铺垫(背包，最长公共子序列），这里以Leetcode 1289.下降路径最小和II为例：1289. 下降路径最小和 II给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。 非零偏移下降路径 定义为：从 grid 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。 示例 1： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]]输出：13解释：所有非零偏移下降路径包括：[1,5,9], [1,5,7], [1,6,7], [1,6,8],[2,4,8], [2,4,9], [2,6,7], [2,6,8],[3,4,8], [3,4,9], [3,5,7], [3,5,9]下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。 示例 2： 输入：grid = [[7]]输出：7 提示： n == grid.length == grid[i].length 1 &lt;= n &lt;= 200 -99 &lt;= grid[i][j] &lt;= 99 这题最直观的想法就是找每一行的最小值，然后一路加到底，但是题目要求是非零偏移下降路径，因此要分为两种情况： 与上一行最小值对齐，即 cur_index=pre_row.index(min)此时不能取最小值，只能寻求上一行的次小值（第二小的值）。 不与上一行最小值对齐，cur_index!=pre_row.index(min)直接取最小值。 因此对于每一行，需要找出最小的两个值，对于需要找出可迭代对象多个最小值/最大值的场景，考虑使用heapq模块里的nsmallest / nlargest(n,iterable)接下来只需要迭代每一行的时候，选择+=哪一个最小值就行。 代码： 1234567class Solution: def minFallingPathSum(self, grid: List[List[int]]) -&gt; int: for pre_row,cur_row in pairwise(grid): min_two=nsmallest(2,pre_row) for i,pre in enumerate(pre_row): cur_row[i]+=min_two[0] if pre!=min_two[0] else min_two[1] return min(grid[-1]) 其中pairwise用来挨个迭代相邻的两个元素，也即：(row[0],row[1]),(row[1],row[2])… 总结下来，DP的思想很像DFS，编写的前提都是我假设前面的已经取到了所需要的值，首先要分析题目属于DP问题当中的哪一种题型，如果不够直接则思考如何转换，然后找出状态转移方程，处理边界条件(使用哨兵)，最后处理数组得到答案。 感想 归纳题型真的很重要，这个和高中数学有相似之处，Dalao做题都是一眼丁真，简单处理之后直接套框架，前期练习需要的就是对题型，框架的理解和把握程度。","link":"/%E5%81%9A%E4%BA%86%E4%B8%80%E7%82%B9dp%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93.html"}],"tags":[{"name":"math","slug":"math","link":"/tags/math/"},{"name":"code","slug":"code","link":"/tags/code/"}],"categories":[],"pages":[{"title":"关于本站","text":"这是一个小小的个人网站 主要用来存放学习过程，主要是算法与开发内容的小地方 本人大一再读，目前正在学习: C/C++ Python Html 想要学习： C# Vue.js Unity 属于是啥都了解一点，但啥都不会的类型。","link":"/about/index.html"}]}